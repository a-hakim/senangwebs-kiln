<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Modeling Editor - Working Solution</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/threebsp@1.0.4/index.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background-color: #1e293b;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 14px;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: auto;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* Shapes Panel */
        .shapes-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            z-index: 20;
            min-width: 320px;
        }

        .panel-tabs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .tab-button {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: #e5e7eb;
            color: #374151;
        }

        .tab-button:hover {
            background-color: #d1d5db;
        }

        .tab-button.active {
            background-color: #2563eb;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .panel-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 12px;
            color: #1f2937;
        }

        .shapes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .shape-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 8px;
            background-color: #10b981;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shape-button:hover {
            background-color: #059669;
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2);
        }

        .shape-button:active {
            transform: translateY(0);
        }

        .shape-button i {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .outliner-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .outliner-item {
            font-size: 13px;
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: transparent;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid transparent;
        }

        .outliner-item:hover {
            background-color: #e0f2fe;
        }

        .outliner-item.selected {
            background-color: #bfdbfe;
            font-weight: 600;
        }

        .outliner-item.group {
            background-color: #fef3c7;
        }

        .outliner-item.group.selected {
            background-color: #fcd34d;
            font-weight: 600;
        }

        /* Controls Panel */
        .controls-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            z-index: 20;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-size: 12px;
            color: #4b5563;
            font-weight: 500;
            white-space: nowrap;
        }

        .control-group select {
            padding: 8px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 12px;
            background-color: white;
            cursor: pointer;
        }

        .button-group {
            display: flex;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #d1d5db;
        }

        .button-group button {
            padding: 8px 12px;
            color: white;
            text-align: center;
            font-size: 12px;
            flex-grow: 1;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }

        .button-group button:last-child {
            border-right: none;
        }

        .button-group.camera-group button:first-child {
            background-color: #1e40af;
        }

        .button-group.camera-group button:first-child:hover {
            background-color: #1e3a8a;
        }

        .button-group.camera-group button:last-child {
            background-color: #3b82f6;
        }

        .button-group.camera-group button:last-child:hover {
            background-color: #2563eb;
        }

        .button-group.transform-group button {
            background-color: #3b82f6;
        }

        .button-group.transform-group button:hover {
            background-color: #2563eb;
        }

        .button-group.transform-group button:first-child {
            background-color: #1e40af;
        }

        .button-group.transform-group button:first-child:hover {
            background-color: #1e3a8a;
        }

        .action-button {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            color: white;
            flex-grow: 1;
            transition: all 0.2s ease;
        }

        .action-button.copy {
            background-color: #06b6d4;
        }

        .action-button.copy:hover {
            background-color: #0891b2;
        }

        .action-button.delete {
            background-color: #ef4444;
        }

        .action-button.delete:hover {
            background-color: #dc2626;
        }

        .action-button.group {
            background-color: #f97316;
        }

        .action-button.group:hover {
            background-color: #ea580c;
        }

        .action-button.ungroup {
            background-color: #f97316;
        }

        .action-button.ungroup:hover {
            background-color: #ea580c;
        }

        .action-button.undo {
            background-color: #a855f7;
        }

        .action-button.undo:hover {
            background-color: #9333ea;
        }

        .action-button.redo {
            background-color: #a855f7;
        }

        .action-button.redo:hover {
            background-color: #9333ea;
        }

        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Property Pane */
        #property-pane {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 288px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            z-index: 20;
            display: none;
        }

        #property-pane.visible {
            display: block;
        }

        .property-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .property-header h3 {
            font-size: 16px;
            font-weight: 700;
            color: #1f2937;
        }

        .property-close {
            font-size: 24px;
            font-weight: 700;
            color: #9ca3af;
            cursor: pointer;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: color 0.2s ease;
        }

        .property-close:hover {
            color: #374151;
        }

        .property-section {
            margin-bottom: 16px;
        }

        .property-section h4 {
            font-size: 12px;
            font-weight: 700;
            color: #374151;
            margin-bottom: 12px;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 8px;
        }

        .property-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .property-row label {
            font-size: 12px;
            font-weight: 500;
            color: #4b5563;
        }

        .property-row input[type="color"] {
            width: 128px;
            height: 32px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 2px;
            cursor: pointer;
        }

        .type-button-group {
            display: flex;
            gap: 8px;
        }

        .type-button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            color: white;
            transition: all 0.2s ease;
        }

        .type-button.solid {
            background-color: #3b82f6;
        }

        .type-button.solid:hover {
            background-color: #2563eb;
        }

        .type-button.solid.active {
            background-color: #1e40af;
        }

        .type-button.hole {
            background-color: #9ca3af;
        }

        .type-button.hole:hover {
            background-color: #6b7280;
        }

        .type-button.hole.active {
            background-color: #6b7280;
        }

        .property-coords {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .property-coord-input {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .property-coord-input label {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 4px;
            text-align: center;
        }

        .property-coord-input input {
            padding: 8px 4px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }
    </style>

</head>

<body>
    <!-- Layer 0: The 3D Canvas. Sits at the very back (z-0). -->
    <div id="canvas-container"></div>

    <div id="ui-container">

        <div class="shapes-panel">
            <div class="panel-tabs">
                <button class="tab-button active" onclick="switchTab('shapes')">Shapes</button>
                <button class="tab-button" onclick="switchTab('outliner')">Outliner</button>
            </div>

            <div id="shapes-content" class="tab-content active">
                <div class="panel-title">Add Shapes</div>
                <div class="shapes-grid">
                    <button class="shape-button" onclick="addShape('box')" title="Box">
                        <i class="fa-solid fa-cube"></i>
                        Box
                    </button>
                    <button class="shape-button" onclick="addShape('sphere')" title="Sphere">
                        <i class="fa-solid fa-circle"></i>
                        Sphere
                    </button>
                    <button class="shape-button" onclick="addShape('cylinder')" title="Cylinder">
                        <i class="fa-solid fa-database"></i>
                        Cylinder
                    </button>
                    <button class="shape-button" onclick="addShape('cone')" title="Cone">
                        <i class="fa-solid fa-caret-up"></i>
                        Cone
                    </button>
                    <button class="shape-button" onclick="addShape('torus')" title="Torus">
                        <i class="fa-solid fa-ring"></i>
                        Torus
                    </button>
                    <button class="shape-button" onclick="addShape('plane')" title="Plane">
                        <i class="fa-solid fa-square"></i>
                        Plane
                    </button>
                    <button class="shape-button" onclick="addShape('capsule')" title="Capsule">
                        <i class="fa-solid fa-capsules"></i>
                        Capsule
                    </button>
                    <button class="shape-button" onclick="addShape('torusknot')" title="Torus Knot">
                        <i class="fa-solid fa-code-branch"></i>
                        Knot
                    </button>
                    <button class="shape-button" onclick="addShape('tetrahedron')" title="Tetrahedron">
                        <i class="fa-solid fa-pyramid"></i>
                        Tetra
                    </button>
                    <button class="shape-button" onclick="addShape('octahedron')" title="Octahedron">
                        <i class="fa-solid fa-gem"></i>
                        Octa
                    </button>
                    <button class="shape-button" onclick="addShape('icosahedron')" title="Icosahedron">
                        <i class="fa-solid fa-ball"></i>
                        Icosa
                    </button>
                    <button class="shape-button" onclick="addShape('dodecahedron')" title="Dodecahedron">
                        <i class="fa-solid fa-dice"></i>
                        Dodeca
                    </button>
                </div>
            </div>

            <div id="outliner-content" class="tab-content">
                <div class="panel-title">Scene Outliner</div>
                <ul id="outliner-list" class="outliner-list"></ul>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="controls-panel">
            <div class="control-group">
                <label for="snap-unit-select">Unit</label>
                <select id="snap-unit-select" onchange="updateSnapSettings()">
                    <option value="0.5">0.5</option>
                    <option value="0.2">0.2</option>
                    <option value="0.1" selected>0.1</option>
                    <option value="0.05">0.05</option>
                    <option value="0.025">0.025</option>
                    <option value="0.01">0.01</option>
                    <option value="0">Off</option>
                </select>
            </div>

            <div class="button-group camera-group">
                <button id="perspective-btn" onclick="setCameraMode('perspective')">Perspective</button>
                <button id="orthographic-btn" onclick="setCameraMode('orthographic')">Orthographic</button>
            </div>

            <div class="button-group transform-group">
                <button id="translate-btn" onclick="setTransformMode('translate')">Translate (T)</button>
                <button id="rotate-btn" onclick="setTransformMode('rotate')">Rotate (R)</button>
                <button id="scale-btn" onclick="setTransformMode('scale')">Scale (S)</button>
            </div>

            <div style="display: flex; gap: 8px;">
                <button class="action-button copy" onclick="duplicateSelected()">Copy</button>
                <button class="action-button delete" onclick="deleteSelected()">Delete</button>
                <button id="group-btn" class="action-button group" onclick="groupSelected()" title="Group selected shapes">ðŸ“¦ Group</button>
                <button id="ungroup-btn" class="action-button ungroup" onclick="ungroupSelected()" title="Ungroup selected group">ðŸ“‚ Ungroup</button>
                <button id="undo-btn" class="action-button undo" onclick="undo()" title="Undo (Ctrl+Z)">â†¶ Undo</button>
                <button id="redo-btn" class="action-button redo" onclick="redo()" title="Redo (Ctrl+Y)">â†· Redo</button>
            </div>
        </div>

        <!-- Property Pane -->
        <div id="property-pane">
            <div class="property-header">
                <h3>Properties</h3>
                <span class="property-close" onclick="closePropertyPane()">&times;</span>
            </div>

            <div class="property-section">
                <h4>Material</h4>
                <div class="property-row">
                    <label for="colorPicker">Color</label>
                    <input type="color" id="colorPicker" value="#ff6b6b" onchange="updateColor()">
                </div>
                <div class="property-row">
                    <label for="shapeTypeToggle">Type</label>
                    <div class="type-button-group">
                        <button id="solid-btn" class="type-button solid active" onclick="setShapeType('solid')" title="Set as Solid">ðŸŸ¦ Solid</button>
                        <button id="hole-btn" class="type-button hole" onclick="setShapeType('hole')" title="Set as Hole">âš« Hole</button>
                    </div>
                </div>
            </div>

            <div class="property-section">
                <h4>Position (m)</h4>
                <div class="property-coords">
                    <div class="property-coord-input">
                        <label>X</label>
                        <input type="number" step="0.1" id="prop-pos-x" onchange="updateObjectFromPane()">
                    </div>
                    <div class="property-coord-input">
                        <label>Y</label>
                        <input type="number" step="0.1" id="prop-pos-y" onchange="updateObjectFromPane()">
                    </div>
                    <div class="property-coord-input">
                        <label>Z</label>
                        <input type="number" step="0.1" id="prop-pos-z" onchange="updateObjectFromPane()">
                    </div>
                </div>
            </div>

            <div class="property-section">
                <h4>Rotation (Â°)</h4>
                <div class="property-coords">
                    <div class="property-coord-input">
                        <label>X</label>
                        <input type="number" id="prop-rot-x" onchange="updateObjectFromPane()">
                    </div>
                    <div class="property-coord-input">
                        <label>Y</label>
                        <input type="number" id="prop-rot-y" onchange="updateObjectFromPane()">
                    </div>
                    <div class="property-coord-input">
                        <label>Z</label>
                        <input type="number" id="prop-rot-z" onchange="updateObjectFromPane()">
                    </div>
                </div>
            </div>

            <div class="property-section">
                <h4>Scale</h4>
                <div class="property-coords">
                    <div class="property-coord-input">
                        <label>X</label>
                        <input type="number" step="0.1" id="prop-scale-x" onchange="updateObjectFromPane()">
                    </div>
                    <div class="property-coord-input">
                        <label>Y</label>
                        <input type="number" step="0.1" id="prop-scale-y" onchange="updateObjectFromPane()">
                    </div>
                    <div class="property-coord-input">
                        <label>Z</label>
                        <input type="number" step="0.1" id="prop-scale-z" onchange="updateObjectFromPane()">
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        let scene, renderer, raycaster, mouse;
        let perspectiveCamera, orthographicCamera, camera;
        let controls, transformControls;
        let currentCameraMode = 'perspective';
        let canvasElement;

        let objects = [];
        let selectedObject = null;
        let selectedObjects = [];  // For multi-selection
        let groups = [];
        let groupIdCounter = 0;
        let shapeCounters = {
            box: 0,
            sphere: 0,
            cylinder: 0,
            cone: 0,
            torus: 0,
            plane: 0,
            capsule: 0,
            torusknot: 0,
            tetrahedron: 0,
            octahedron: 0,
            icosahedron: 0,
            dodecahedron: 0
        };

        // Undo/Redo History
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // Tab switching function
        function switchTab(tabName) {
            // Hide all tabs
            document.getElementById('shapes-content').classList.remove('active');
            document.getElementById('outliner-content').classList.remove('active');
            
            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Show selected tab
            if (tabName === 'shapes') {
                document.getElementById('shapes-content').classList.add('active');
                buttons[0].classList.add('active');
            } else if (tabName === 'outliner') {
                document.getElementById('outliner-content').classList.add('active');
                buttons[1].classList.add('active');
            }
        }

        // Shape Type Management
        function getMaterialForType(type) {
            if (type === 'hole') {
                return new THREE.MeshStandardMaterial({
                    color: '#888888',
                    roughness: 0.7,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.3,
                    wireframe: false
                });
            } else {
                // Solid - use original color if available
                const color = selectedObject && selectedObject.userData.color
                    ? selectedObject.userData.color
                    : '#ff6b6b';
                return new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.5,
                    metalness: 0.3,
                    transparent: false,
                    opacity: 1.0
                });
            }
        }

        function setShapeType(type) {
            if (!selectedObject) return;
            selectedObject.userData.shapeType = type;
            
            // Update material based on type
            if (type === 'hole') {
                selectedObject.material = new THREE.MeshStandardMaterial({
                    color: '#888888',
                    roughness: 0.7,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.3
                });
            } else {
                selectedObject.material = new THREE.MeshStandardMaterial({
                    color: selectedObject.userData.color || '#ff6b6b',
                    roughness: 0.5,
                    metalness: 0.3,
                    transparent: false,
                    opacity: 1.0
                });
            }
            
            updatePropertyPane();
            updateOutliner();
            captureState();
        }

        function captureState() {
            // Remove any forward history if we made a new change
            history = history.slice(0, historyIndex + 1);
            
            // Create a snapshot of current state
            const state = {
                objects: objects.map(obj => ({
                    name: obj.name,
                    position: obj.position.clone(),
                    rotation: obj.rotation.clone(),
                    scale: obj.scale.clone(),
                    color: obj.userData.color || obj.material.color.getHex(),
                    shapeType: obj.userData.shapeType || 'solid',
                    uuid: obj.uuid,
                    groupId: obj.userData.groupId || null
                })),
                groups: groups.map(g => ({
                    id: g.id,
                    name: g.name,
                    children: g.children.map(c => c.uuid)
                })),
                selectedObjectUuids: selectedObjects.map(obj => obj.uuid),
                shapeCounters: { ...shapeCounters }
            };
            
            history.push(state);
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
            
            updateHistoryButtons();
        }

        function restoreState(state) {
            if (!state) return;
            
            // Remove objects not in state
            objects.forEach(obj => scene.remove(obj));
            groups.forEach(g => {
                if (g.resultMesh) scene.remove(g.resultMesh);
            });
            objects = [];
            groups = [];
            
            // Recreate objects from state
            state.objects.forEach(objState => {
                // Find geometry type from name
                const type = objState.name.split(' ')[0].toLowerCase();
                let geometry;
                switch (type) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(0.5, 32, 32);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(0.5, 1, 32);
                        break;
                    case 'torus':
                        geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
                        break;
                    case 'plane':
                        geometry = new THREE.PlaneGeometry(1, 1);
                        break;
                    case 'capsule':
                        geometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
                        break;
                    case 'torusknot':
                        geometry = new THREE.TorusKnotGeometry(0.4, 0.15, 100, 16);
                        break;
                    case 'tetrahedron':
                        geometry = new THREE.TetrahedronGeometry(0.7);
                        break;
                    case 'octahedron':
                        geometry = new THREE.OctahedronGeometry(0.7);
                        break;
                    case 'icosahedron':
                        geometry = new THREE.IcosahedronGeometry(0.7);
                        break;
                    case 'dodecahedron':
                        geometry = new THREE.DodecahedronGeometry(0.7);
                        break;
                }
                
                // Ensure geometry has proper bounds
                geometry.computeBoundingBox();
                geometry.computeBoundingSphere();
                geometry.center();
                
                // Determine material based on shape type
                let material;
                if (objState.shapeType === 'hole') {
                    material = new THREE.MeshStandardMaterial({
                        color: '#888888',
                        roughness: 0.7,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.3
                    });
                } else {
                    material = new THREE.MeshStandardMaterial({
                        color: objState.color,
                        roughness: 0.5,
                        metalness: 0.3,
                        transparent: false,
                        opacity: 1.0
                    });
                }
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = objState.name;
                mesh.uuid = objState.uuid;
                mesh.userData.shapeType = objState.shapeType || 'solid';
                mesh.userData.color = objState.color;
                mesh.userData.groupId = objState.groupId || null;
                mesh.position.copy(objState.position);
                mesh.rotation.copy(objState.rotation);
                mesh.scale.copy(objState.scale);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                scene.add(mesh);
                objects.push(mesh);
            });
            
            // Restore groups
            state.groups.forEach(groupState => {
                const group = {
                    id: groupState.id,
                    name: groupState.name,
                    children: groupState.children.map(uuid => objects.find(o => o.uuid === uuid)).filter(o => o),
                    resultMesh: null,
                    isDirty: true
                };
                groups.push(group);
                if (group.children.length > 0) {
                    computeGroupResult(group);
                }
            });
            
            shapeCounters = { ...state.shapeCounters };
            
            // Restore selection
            if (state.selectedObjectUuids && state.selectedObjectUuids.length > 0) {
                selectedObjects = [];
                state.selectedObjectUuids.forEach(uuid => {
                    const obj = objects.find(o => o.uuid === uuid);
                    if (obj) {
                        selectedObjects.push(obj);
                        if (obj.material && obj.material.emissive) {
                            obj.material.emissive.setHex(0x555555);
                        }
                    }
                });
                selectedObject = selectedObjects.length > 0 ? selectedObjects[0] : null;
                
                if (selectedObjects.length === 1) {
                    document.getElementById('property-pane').classList.add('visible');
                    updatePropertyPane();
                    transformControls.attach(selectedObject);
                } else if (selectedObjects.length > 1) {
                    document.getElementById('property-pane').classList.remove('visible');
                    transformControls.detach();
                }
            } else {
                deselectObject();
            }
            
            updateOutliner();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(history[historyIndex]);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(history[historyIndex]);
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        // Boolean CSG Computation
        function computeGroupResult(group) {
            if (group.resultMesh) {
                scene.remove(group.resultMesh);
            }
            
            if (group.children.length === 0) return;
            
            try {
                let resultGeometry = null;
                
                for (let i = 0; i < group.children.length; i++) {
                    const child = group.children[i];
                    const childBSP = new ThreeBSP(child);
                    
                    if (resultGeometry === null) {
                        resultGeometry = childBSP;
                    } else {
                        const resultBSP = new ThreeBSP(resultGeometry.toMesh());
                        
                        if (child.userData.shapeType === 'hole') {
                            resultGeometry = resultBSP.subtract(childBSP);
                        } else {
                            resultGeometry = resultBSP.union(childBSP);
                        }
                    }
                }
                
                if (resultGeometry) {
                    const resultMesh = resultGeometry.toMesh();
                    resultMesh.material = new THREE.MeshStandardMaterial({
                        color: '#ff9800',
                        roughness: 0.5,
                        metalness: 0.3
                    });
                    resultMesh.castShadow = true;
                    resultMesh.receiveShadow = true;
                    resultMesh.userData.isGroupResult = true;
                    resultMesh.userData.groupId = group.id;
                    
                    scene.add(resultMesh);
                    group.resultMesh = resultMesh;
                    group.isDirty = false;
                }
            } catch (e) {
                console.error("Error computing Boolean result:", e);
            }
        }

        function groupSelected() {
            if (selectedObjects.length < 1) {
                console.log("No objects selected for grouping");
                return;
            }
            
            console.log(`Grouping ${selectedObjects.length} objects`);
            
            const groupId = `group_${groupIdCounter++}`;
            const group = {
                id: groupId,
                name: `Group ${groups.length + 1}`,
                children: [...selectedObjects],
                resultMesh: null,
                isDirty: true
            };
            
            // Mark objects as part of group
            selectedObjects.forEach(obj => {
                obj.userData.groupId = groupId;
                scene.remove(obj);
            });
            
            groups.push(group);
            computeGroupResult(group);
            
            // Hide original objects, show result
            selectedObjects.forEach(obj => {
                obj.visible = false;
            });
            
            deselectObject();
            selectObject(group.resultMesh);
            updateOutliner();
            captureState();
        }

        function ungroupSelected() {
            if (!selectedObject || !selectedObject.userData.isGroupResult) return;
            
            const groupId = selectedObject.userData.groupId;
            const groupIndex = groups.findIndex(g => g.id === groupId);
            
            if (groupIndex === -1) return;
            
            const group = groups[groupIndex];
            
            // Show original objects
            group.children.forEach(obj => {
                obj.visible = true;
                obj.userData.groupId = null;
            });
            
            // Remove result mesh
            scene.remove(group.resultMesh);
            groups.splice(groupIndex, 1);
            
            if (group.children.length > 0) {
                selectObject(group.children[0]);
            } else {
                deselectObject();
            }
            
            updateOutliner();
            captureState();
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x334155);

            const aspect = window.innerWidth / window.innerHeight;
            perspectiveCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            const frustumSize = 10;
            orthographicCamera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2, 0.1, 1000);

            camera = perspectiveCamera;
            camera.position.set(5, 5, 5);

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const container = document.getElementById('canvas-container');
            container.appendChild(renderer.domElement);
            canvasElement = renderer.domElement;
            
            // Ensure canvas is clickable
            canvasElement.style.pointerEvents = 'auto';
            console.log("Canvas initialized:", canvasElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            scene.add(new THREE.GridHelper(20, 20, 0x475569, 0x64748b));

            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', event => {
                controls.enabled = !event.value;
                if (!event.value) {
                    // Capture state when transform finishes
                    captureState();
                }
            });
            transformControls.addEventListener('objectChange', updatePropertyPane);
            scene.add(transformControls);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Single click listener on canvas
            canvasElement.addEventListener('click', onCanvasClick, false);
            console.log("Canvas click listener attached");

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);

            updateSnapSettings();
            setTransformMode('translate');
            updateOutliner();
            updateHistoryButtons();
            animate();
        }

        function onCanvasClick(event) {
            console.log("âœ“ Canvas click fired, target:", event.target.tagName);
            performRaycast(event);
        }

        function performRaycast(event) {
            if (transformControls.dragging) return;

            const rect = canvasElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Collect all selectable objects
            const selectableObjects = [];
            objects.forEach(obj => {
                if (obj.visible && !obj.userData.isGroupResult) {
                    selectableObjects.push(obj);
                }
            });
            groups.forEach(group => {
                if (group.resultMesh && group.resultMesh.visible) {
                    selectableObjects.push(group.resultMesh);
                }
            });
            
            const intersects = raycaster.intersectObjects(selectableObjects);
            
            console.log("ðŸ–±ï¸ Click - Objects:", selectableObjects.length, "Hits:", intersects.length);
            
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                console.log("âœ… Hit:", clickedObject.name);
                
                // Ctrl/Cmd + click for multi-select
                if (event.ctrlKey || event.metaKey) {
                    console.log("Ctrl+Click - Multi-select mode");
                    toggleObjectSelection(clickedObject);
                } else {
                    console.log("Regular click - Single select");
                    selectObject(clickedObject);
                }
            } else {
                console.log("âŒ Missed");
                deselectObject();
            }
        }

        function addShape(type) {
            let geometry;
            switch (type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.5, 32, 32);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(0.5, 1, 32);
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
                    break;
                case 'plane':
                    geometry = new THREE.PlaneGeometry(1, 1);
                    break;
                case 'capsule':
                    geometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
                    break;
                case 'torusknot':
                    geometry = new THREE.TorusKnotGeometry(0.4, 0.15, 100, 16);
                    break;
                case 'tetrahedron':
                    geometry = new THREE.TetrahedronGeometry(0.7);
                    break;
                case 'octahedron':
                    geometry = new THREE.OctahedronGeometry(0.7);
                    break;
                case 'icosahedron':
                    geometry = new THREE.IcosahedronGeometry(0.7);
                    break;
                case 'dodecahedron':
                    geometry = new THREE.DodecahedronGeometry(0.7);
                    break;
            }
            
            // Ensure geometry has proper bounds
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            geometry.center();
            
            const material = new THREE.MeshStandardMaterial({
                color: '#ff6b6b',
                roughness: 0.5,
                metalness: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            shapeCounters[type]++;
            mesh.name = `${type.charAt(0).toUpperCase() + type.slice(1)} ${shapeCounters[type]}`;
            mesh.position.y = 0.5;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.shapeType = 'solid';
            mesh.userData.color = '#ff6b6b';
            scene.add(mesh);
            objects.push(mesh);
            selectObject(mesh);
            captureState();
        }

        function deselectObject() {
            if (selectedObject) {
                if (selectedObject.material && selectedObject.material.emissive) {
                    selectedObject.material.emissive.setHex(0x000000);
                }
            }
            selectedObject = null;
            selectedObjects = [];
            transformControls.detach();
            document.getElementById('property-pane').classList.remove('visible');
            updateOutliner();
        }

        function toggleObjectSelection(obj) {
            // Check if already selected
            const index = selectedObjects.indexOf(obj);
            if (index > -1) {
                // Remove from selection
                selectedObjects.splice(index, 1);
                if (obj.material && obj.material.emissive) {
                    obj.material.emissive.setHex(0x000000);
                }
                console.log(`Deselected: ${obj.name}, Total selected: ${selectedObjects.length}`);
            } else {
                // Add to selection
                selectedObjects.push(obj);
                if (obj.material && obj.material.emissive) {
                    obj.material.emissive.setHex(0x555555);
                }
                console.log(`Selected: ${obj.name}, Total selected: ${selectedObjects.length}`);
            }
            
            // Update references
            selectedObject = selectedObjects.length > 0 ? selectedObjects[0] : null;
            
            // Show property pane only if 1 object selected
            if (selectedObjects.length === 1) {
                document.getElementById('property-pane').classList.add('visible');
                updatePropertyPane();
                transformControls.attach(selectedObject);
            } else if (selectedObjects.length > 1) {
                // Multiple selection - hide property pane
                document.getElementById('property-pane').classList.remove('visible');
                transformControls.detach();
            } else {
                // No selection
                document.getElementById('property-pane').classList.remove('visible');
                transformControls.detach();
            }
            
            updateOutliner();
        }

        function selectObject(obj) {
            if (!obj) return;
            
            // Clear previous selection and start fresh
            selectedObjects.forEach(sel => {
                if (sel.material && sel.material.emissive) {
                    sel.material.emissive.setHex(0x000000);
                }
            });
            
            selectedObjects = [obj];
            selectedObject = obj;
            
            // Set emissive highlight
            if (selectedObject.material && selectedObject.material.emissive) {
                selectedObject.material.emissive.setHex(0x555555);
            }
            
            transformControls.attach(selectedObject);
            document.getElementById('property-pane').classList.add('visible');
            updatePropertyPane();
            updateOutliner();
            console.log(`Single selected: ${obj.name}`);
        }

        function updateOutliner() {
            const outlinerList = document.getElementById('outliner-list');
            outlinerList.innerHTML = '';
            
            // Show regular objects
            objects.forEach(obj => {
                if (obj.visible) {
                    const li = document.createElement('li');
                    li.className = 'outliner-item';
                    if (selectedObjects.includes(obj)) {
                        li.classList.add('selected');
                    }
                    
                    const icon = obj.userData.shapeType === 'hole' ? 'âš«' : 'ðŸŸ¦';
                    li.innerHTML = `<span>${icon}</span><span>${obj.name}</span>`;
                    li.onclick = (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            toggleObjectSelection(obj);
                        } else {
                            selectObject(obj);
                        }
                    };
                    outlinerList.appendChild(li);
                }
            });
            
            // Show groups
            groups.forEach(group => {
                const li = document.createElement('li');
                li.className = 'outliner-item group';
                if (selectedObjects.includes(group.resultMesh)) {
                    li.classList.add('selected');
                }
                
                li.innerHTML = `<span>ðŸ“¦</span><span>${group.name}</span>`;
                li.onclick = () => {
                    selectObject(group.resultMesh);
                };
                outlinerList.appendChild(li);
            });
        }

        function onKeyDown(e) {
            if (e.target.tagName === 'INPUT') return;
            switch (e.key.toLowerCase()) {
                case 't':
                    setTransformMode('translate');
                    break;
                case 'r':
                    setTransformMode('rotate');
                    break;
                case 's':
                    setTransformMode('scale');
                    break;
                case 'delete':
                case 'backspace':
                    deleteSelected();
                    e.preventDefault();
                    break;
                case 'z':
                    if (e.ctrlKey) {
                        undo();
                        e.preventDefault();
                    }
                    break;
                case 'y':
                    if (e.ctrlKey) {
                        redo();
                        e.preventDefault();
                    }
                    break;
            }
        }

        function updateSnapSettings() {
            const selectElement = document.getElementById('snap-unit-select');
            const newSnapValue = parseFloat(selectElement.value);
            if (newSnapValue === 0) {
                transformControls.setTranslationSnap(null);
                transformControls.setRotationSnap(null);
                transformControls.setScaleSnap(null);
            } else {
                transformControls.setTranslationSnap(newSnapValue);
                transformControls.setRotationSnap(THREE.MathUtils.degToRad(15));
                transformControls.setScaleSnap(newSnapValue);
            }
        }

        function setTransformMode(mode) {
            transformControls.setMode(mode);
            const buttons = {
                translate: document.getElementById('translate-btn'),
                rotate: document.getElementById('rotate-btn'),
                scale: document.getElementById('scale-btn')
            };
            for (const key in buttons) {
                const button = buttons[key];
                if (key === mode) {
                    button.style.backgroundColor = '#1e40af';
                } else {
                    button.style.backgroundColor = '#3b82f6';
                }
            }
        }

        function setCameraMode(mode) {
            if (mode === currentCameraMode) return;
            const newCam = (mode === 'perspective') ? perspectiveCamera : orthographicCamera;
            newCam.position.copy(camera.position);
            newCam.rotation.copy(camera.rotation);
            newCam.zoom = camera.zoom;
            camera = newCam;
            controls.object = camera;
            transformControls.camera = camera;
            camera.updateProjectionMatrix();
            controls.update();
            currentCameraMode = mode;
            const pBtn = document.getElementById('perspective-btn');
            const oBtn = document.getElementById('orthographic-btn');
            
            if (mode === 'perspective') {
                pBtn.style.backgroundColor = '#1e40af';
                oBtn.style.backgroundColor = '#3b82f6';
            } else {
                pBtn.style.backgroundColor = '#3b82f6';
                oBtn.style.backgroundColor = '#1e40af';
            }
        }

        function updateColor() {
            if (selectedObject) {
                const newColor = document.getElementById('colorPicker').value;
                selectedObject.userData.color = newColor;
                selectedObject.material.color.set(newColor);
                captureState();
            }
        }

        function duplicateSelected() {
            if (selectedObjects.length === 0) return;
            
            console.log(`Duplicating ${selectedObjects.length} objects`);
            const clones = [];
            
            selectedObjects.forEach(obj => {
                const clone = obj.clone();
                clone.material = obj.material.clone();
                clone.position.x += 1.5;
                let originalType = obj.name.split(' ')[0].toLowerCase();
                shapeCounters[originalType]++;
                clone.name = `${originalType.charAt(0).toUpperCase() + originalType.slice(1)} ${shapeCounters[originalType]}`;
                scene.add(clone);
                objects.push(clone);
                clones.push(clone);
            });
            
            // Select all the clones
            deselectObject();
            clones.forEach(clone => {
                selectedObjects.push(clone);
                if (clone.material && clone.material.emissive) {
                    clone.material.emissive.setHex(0x555555);
                }
            });
            selectedObject = clones.length > 0 ? clones[0] : null;
            
            if (clones.length === 1) {
                document.getElementById('property-pane').classList.add('visible');
                updatePropertyPane();
                transformControls.attach(selectedObject);
            } else if (clones.length > 1) {
                document.getElementById('property-pane').classList.remove('visible');
            }
            
            updateOutliner();
            captureState();
        }

        function deleteSelected() {
            if (selectedObjects.length === 0) return;
            
            console.log(`Deleting ${selectedObjects.length} objects`);
            selectedObjects.forEach(objToRemove => {
                scene.remove(objToRemove);
                objects = objects.filter(obj => obj !== objToRemove);
            });
            
            deselectObject();
            updateOutliner();
            captureState();
        }

        function closePropertyPane() {
            deselectObject();
        }

        function updatePropertyPane() {
            if (!selectedObject) return;
            
            // Handle color - check userData or material
            let colorValue = '#ff6b6b';
            if (selectedObject.userData && selectedObject.userData.color) {
                colorValue = selectedObject.userData.color;
            } else if (selectedObject.material && selectedObject.material.color) {
                colorValue = '#' + selectedObject.material.color.getHexString();
            }
            
            // Ensure color value starts with #
            if (typeof colorValue === 'string' && !colorValue.startsWith('#')) {
                colorValue = '#' + colorValue;
            }
            document.getElementById('colorPicker').value = colorValue;
            
            // Update solid/hole buttons
            const shapeType = (selectedObject.userData && selectedObject.userData.shapeType) ? selectedObject.userData.shapeType : 'solid';
            const solidBtn = document.getElementById('solid-btn');
            const holeBtn = document.getElementById('hole-btn');
            
            solidBtn.classList.remove('active');
            holeBtn.classList.remove('active');
            
            if (shapeType === 'solid') {
                solidBtn.classList.add('active');
            } else {
                holeBtn.classList.add('active');
            }
            
            document.getElementById('prop-pos-x').value = selectedObject.position.x.toFixed(3);
            document.getElementById('prop-pos-y').value = selectedObject.position.y.toFixed(3);
            document.getElementById('prop-pos-z').value = selectedObject.position.z.toFixed(3);
            document.getElementById('prop-rot-x').value = THREE.MathUtils.radToDeg(selectedObject.rotation.x).toFixed(1);
            document.getElementById('prop-rot-y').value = THREE.MathUtils.radToDeg(selectedObject.rotation.y).toFixed(1);
            document.getElementById('prop-rot-z').value = THREE.MathUtils.radToDeg(selectedObject.rotation.z).toFixed(1);
            document.getElementById('prop-scale-x').value = selectedObject.scale.x.toFixed(3);
            document.getElementById('prop-scale-y').value = selectedObject.scale.y.toFixed(3);
            document.getElementById('prop-scale-z').value = selectedObject.scale.z.toFixed(3);
        }

        function updateObjectFromPane() {
            if (!selectedObject) return;
            selectedObject.position.set(parseFloat(document.getElementById('prop-pos-x').value), parseFloat(document
                .getElementById('prop-pos-y').value), parseFloat(document.getElementById('prop-pos-z').value));
            selectedObject.rotation.set(THREE.MathUtils.degToRad(parseFloat(document.getElementById('prop-rot-x').value)),
                THREE.MathUtils.degToRad(parseFloat(document.getElementById('prop-rot-y').value)), THREE.MathUtils
                .degToRad(parseFloat(document.getElementById('prop-rot-z').value)));
            selectedObject.scale.set(parseFloat(document.getElementById('prop-scale-x').value), parseFloat(document
                .getElementById('prop-scale-y').value), parseFloat(document.getElementById('prop-scale-z').value));
            captureState();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>
