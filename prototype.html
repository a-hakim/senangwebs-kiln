<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Modeling Editor - Working Solution</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/threebsp@1.0.4/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>

</head>

<body class="overflow-hidden bg-slate-800 font-system" <!-- Layer 0: The 3D Canvas. Sits at the very back (z-0). -->
    <div id="canvas-container" class="fixed top-0 left-0 w-full h-full z-0 pointer-events-auto"></div>

    <div id="ui-container" class="fixed top-0 left-0 w-full h-full z-10 pointer-events-none">

        <div
            class="shapes-panel absolute top-2 left-2 bg-white bg-opacity-95 p-3 rounded-xl pointer-events-auto z-20 min-w-80">
            <div class="panel-tabs grid grid-cols-2 gap-2 mb-3">
                <button
                    class="tab-button px-3 py-2 border-none rounded text-gray-700 text-sm font-medium cursor-pointer transition-all hover:bg-gray-300 active bg-blue-500 text-white"
                    onclick="switchTab('shapes')">Shapes</button>
                <button
                    class="tab-button px-3 py-2 border-none rounded bg-gray-200 text-gray-700 text-sm font-medium cursor-pointer transition-all hover:bg-gray-300"
                    onclick="switchTab('outliner')">Outliner</button>
            </div>

            <div id="shapes-content" class="tab-content">
                <div class="text-base font-bold text-gray-900 mb-3">Add Shapes</div>
                <div class="grid grid-cols-3 gap-2">
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('box')" title="Box">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Box
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('sphere')" title="Sphere">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Sphere
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('cylinder')" title="Cylinder">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Cylinder
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('cone')" title="Cone">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Cone
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('torus')" title="Torus">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Torus
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('plane')" title="Plane">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Plane
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('pyramid')" title="Pyramid">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Pyramid
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('torusknot')" title="Torus Knot">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Knot
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('tetrahedron')" title="Tetrahedron">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Tetra
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('octahedron')" title="Octahedron">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Octa
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('icosahedron')" title="Icosahedron">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Icosa
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('dodecahedron')" title="Dodecahedron">
                        <i class="fa-solid fa-shapes text-xl mb-1"></i>
                        Dodeca
                    </button>
                    <button
                        class="shape-button flex flex-col items-center p-3 bg-emerald-500 text-white border-none rounded text-xs cursor-pointer transition-all hover:bg-emerald-600 hover:-translate-y-0.5 hover:shadow-lg active:translate-y-0"
                        onclick="addShape('text')" title="3D Text">
                        <i class="fa-solid fa-font text-xl mb-1"></i>
                        Text
                    </button>
                </div>
            </div>

            <div id="outliner-content" class="tab-content hidden">
                <div class="text-base font-bold text-gray-900 mb-3">Scene Outliner</div>
                <ul id="outliner-list" class="flex flex-col"></ul>
            </div>
        </div>

        <!-- Controls Panel -->
        <div
            class="controls-panel absolute bottom-2 left-1/2 -translate-x-1/2 bg-white bg-opacity-95 p-1 rounded-xl pointer-events-auto z-20 flex gap-1 flex-wrap justify-center items-center">
            <div class="control-group flex items-center gap-2">
                <select id="snap-unit-select" onchange="updateSnapSettings()"
                    class="px-2 h-10 flex justify-center items-center rounded-lg bg-gray-100 text-xs cursor-pointer">
                    <option value="0.5">0.5</option>
                    <option value="0.2">0.2</option>
                    <option value="0.1" selected>0.1</option>
                    <option value="0.05">0.05</option>
                    <option value="0.025">0.025</option>
                    <option value="0.01">0.01</option>
                    <option value="0">Off</option>
                </select>
            </div>

            <div class="button-group flex rounded-lg overflow-hidden">
                <button id="perspective-btn" onclick="setCameraMode('perspective')"
                    class="px-4 h-10 flex justify-center items-center text-white text-center text-xs flex-grow border-none cursor-pointer transition-all border-r border-white border-opacity-20 bg-blue-900 hover:bg-blue-800">Perspective</button>
                <button id="orthographic-btn" onclick="setCameraMode('orthographic')"
                    class="px-4 h-10 flex justify-center items-center text-white text-center text-xs flex-grow border-none cursor-pointer transition-all bg-blue-500 hover:bg-blue-600">Orthographic</button>
            </div>

            <div class="button-group flex rounded-lg overflow-hidden">
                <button id="translate-btn" onclick="setTransformMode('translate')"
                    class="w-10 h-10 flex justify-center items-center text-white text-center text-xs flex-grow border-none cursor-pointer transition-all border-r border-white border-opacity-20 bg-blue-900 hover:bg-blue-800"><i
                        class="fa-solid fa-arrows-up-down-left-right"></i></button>
                <button id="rotate-btn" onclick="setTransformMode('rotate')"
                    class="w-10 h-10 flex justify-center items-center text-white text-center text-xs flex-grow border-none cursor-pointer transition-all border-r border-white border-opacity-20 bg-blue-500 hover:bg-blue-600"><i
                        class="fa-solid fa-rotate-right"></i></button>
                <button id="scale-btn" onclick="setTransformMode('scale')"
                    class="w-10 h-10 flex justify-center items-center text-white text-center text-xs flex-grow border-none cursor-pointer transition-all bg-blue-500 hover:bg-blue-600"><i
                        class="fa-solid fa-up-right-and-down-left-from-center"></i></button>
            </div>

            <div class="flex gap-1">
                <button
                    class="px-3 py-2 border-none rounded text-xs cursor-pointer text-white transition-all bg-cyan-500 hover:bg-cyan-600"
                    onclick="duplicateSelected()">Copy</button>
                <button
                    class="px-3 py-2 border-none rounded text-xs cursor-pointer text-white transition-all bg-red-500 hover:bg-red-600"
                    onclick="deleteSelected()">Delete</button>
                <button id="group-btn"
                    class="px-3 py-2 border-none rounded text-xs cursor-pointer text-white transition-all bg-orange-500 hover:bg-orange-600"
                    onclick="groupSelected()" title="Group selected shapes"><i
                        class="fa-regular fa-object-group"></i></button>
                <button id="ungroup-btn"
                    class="px-3 py-2 border-none rounded text-xs cursor-pointer text-white transition-all bg-orange-500 hover:bg-orange-600"
                    onclick="ungroupSelected()" title="Ungroup selected group"><i
                        class="fa-regular fa-object-ungroup"></i></button>
                <button id="undo-btn"
                    class="px-3 py-2 border-none rounded text-xs cursor-pointer text-white transition-all bg-purple-500 hover:bg-purple-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    onclick="undo()" title="Undo (Ctrl+Z)"><i class="fa-solid fa-arrow-rotate-left"></i></button>
                <button id="redo-btn"
                    class="px-3 py-2 border-none rounded text-xs cursor-pointer text-white transition-all bg-purple-500 hover:bg-purple-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    onclick="redo()" title="Redo (Ctrl+Y)"><i class="fa-solid fa-arrow-rotate-right"></i></button>
                <button
                    class="px-3 py-2 border-none rounded text-xs cursor-pointer text-white transition-all bg-green-500 hover:bg-green-600"
                    onclick="exportGLTF()" title="Export as GLTF"><i class="fa-solid fa-download"></i> GLTF</button>
                <button
                    class="px-3 py-2 border-none rounded text-xs cursor-pointer text-white transition-all bg-green-500 hover:bg-green-600"
                    onclick="exportSTL()" title="Export as STL"><i class="fa-solid fa-download"></i> STL</button>
            </div>
        </div>

        <!-- Property Pane -->
        <div id="property-pane"
            class="absolute top-2 right-2 w-72 bg-white bg-opacity-95 p-3 rounded-xl pointer-events-auto z-20 hidden flex flex-col gap-4">
            <div class="flex justify-between items-center">
                <h3 class="text-base font-bold text-gray-900">Properties</h3>
                <span
                    class="property-close text-2xl font-bold text-gray-400 cursor-pointer w-6 h-6 flex justify-center items-center transition-colors hover:text-gray-700"
                    onclick="closePropertyPane()">&times;</span>
            </div>

            <div id="property-material-section">
                <h4 class="text-xs font-bold text-gray-700 mb-3">Material</h4>
                <div class="flex justify-between items-center mb-3 gap-2">
                    <label for="colorPicker" class="text-xs font-medium text-gray-600 flex-grow">Color</label>
                    <input type="color" id="colorPicker" value="#007370" onchange="updateColor()"
                        class="w-8 h-8 border border-gray-300 rounded-sm p-0.5 cursor-pointer">
                    <input type="text" id="hexInput" value="ff6b6b" maxlength="7" placeholder="#000000" 
                        onchange="updateColorFromHex()" 
                        class="flex-1 px-2 py-1 border border-gray-300 rounded text-xs font-mono w-20 h-8">
                </div>
            </div>

            <div id="property-position-section">
                <h4 class="text-xs font-bold text-gray-700 mb-3">Position (m)</h4>
                <div class="grid grid-cols-3 gap-2 w-full">
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-500 mb-1 text-center" for="prop-pos-x">X</label>
                        <input type="number" step="0.1" id="prop-pos-x" onchange="updateObjectFromPane()"
                            class="px-1 py-2 border border-gray-300 rounded text-center text-xs">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-500 mb-1 text-center" for="prop-pos-y">Y</label>
                        <input type="number" step="0.1" id="prop-pos-y" onchange="updateObjectFromPane()"
                            class="px-1 py-2 border border-gray-300 rounded text-center text-xs">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-500 mb-1 text-center" for="prop-pos-z">Z</label>
                        <input type="number" step="0.1" id="prop-pos-z" onchange="updateObjectFromPane()"
                            class="px-1 py-2 border border-gray-300 rounded text-center text-xs">
                    </div>
                </div>
            </div>

            <div id="property-rotation-section">
                <h4 class="text-xs font-bold text-gray-700 mb-3">Rotation (¬∞)</h4>
                <div class="grid grid-cols-3 gap-2 w-full">
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-500 mb-1 text-center" for="prop-rot-x">X</label>
                        <input type="number" id="prop-rot-x" onchange="updateObjectFromPane()"
                            class="px-1 py-2 border border-gray-300 rounded text-center text-xs">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-500 mb-1 text-center" for="prop-rot-y">Y</label>
                        <input type="number" id="prop-rot-y" onchange="updateObjectFromPane()"
                            class="px-1 py-2 border border-gray-300 rounded text-center text-xs">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-500 mb-1 text-center" for="prop-rot-z">Z</label>
                        <input type="number" id="prop-rot-z" onchange="updateObjectFromPane()"
                            class="px-1 py-2 border border-gray-300 rounded text-center text-xs">
                    </div>
                </div>
            </div>

            <div id="property-scale-section">
                <h4 class="text-xs font-bold text-gray-700 mb-3">Scale</h4>
                <div class="grid grid-cols-3 gap-2 w-full">
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-500 mb-1 text-center" for="prop-scale-x">X</label>
                        <input type="number" step="0.1" id="prop-scale-x" onchange="updateObjectFromPane()"
                            class="px-1 py-2 border border-gray-300 rounded text-center text-xs">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-500 mb-1 text-center" for="prop-scale-y">Y</label>
                        <input type="number" step="0.1" id="prop-scale-y" onchange="updateObjectFromPane()"
                            class="px-1 py-2 border border-gray-300 rounded text-center text-xs">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-500 mb-1 text-center" for="prop-scale-z">Z</label>
                        <input type="number" step="0.1" id="prop-scale-z" onchange="updateObjectFromPane()"
                            class="px-1 py-2 border border-gray-300 rounded text-center text-xs">
                    </div>
                </div>
            </div>

            <div id="property-text-section" class="hidden">
                <h4 class="text-xs font-bold text-gray-700 mb-3">Text Properties</h4>
                <div class="flex flex-col gap-3">
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-600 mb-1" for="prop-text-content">Text</label>
                        <input type="text" id="prop-text-content" onchange="updateTextContent()" placeholder="Enter text"
                            class="px-2 py-1 border border-gray-300 rounded text-xs w-full">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-600 mb-1" for="prop-text-font">Font</label>
                        <select id="prop-text-font" onchange="updateTextFont()"
                            class="px-2 py-1 border border-gray-300 rounded text-xs w-full">
                            <option value="sans">Sans-serif</option>
                            <option value="mono">Monospace</option>
                            <option value="serif">Serif</option>
                        </select>
                    </div>
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-600 mb-1" for="prop-text-height">Height</label>
                        <input type="number" step="0.1" id="prop-text-height" onchange="updateTextHeight()" min="0.1"
                            class="px-2 py-1 border border-gray-300 rounded text-center text-xs">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-xs text-gray-600 mb-1" for="prop-text-bevel">Bevel</label>
                        <input type="number" step="0.01" id="prop-text-bevel" onchange="updateTextBevel()" min="0"
                            class="px-2 py-1 border border-gray-300 rounded text-center text-xs">
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Color configuration
        const VIEWPORT_BG_COLOR = 0xe2e8f0;
        const GRID_COLOR_CENTER = 0x45556c;
        const GRID_COLOR_LINES = 0x90a1b9;
        const OUTLINE_COLOR = 0x1d293d;

        let scene, renderer, raycaster, mouse;
        let perspectiveCamera, orthographicCamera, camera;
        let controls, transformControls;
        let currentCameraMode = 'perspective';
        let canvasElement;
        let gridHelper;

        let objects = [];
        let selectedObject = null;
        let selectedObjects = []; // For multi-selection
        let groups = [];
        let groupIdCounter = 0;
        let outlineMap = new Map(); // Maps meshes to their outline data (use Map instead of WeakMap for iteration)
        let fontLoader = new THREE.FontLoader();
        let fonts = {}; // Cache loaded fonts
        let shapeCounters = {
            box: 0,
            sphere: 0,
            cylinder: 0,
            cone: 0,
            torus: 0,
            plane: 0,
            pyramid: 0,
            torusknot: 0,
            tetrahedron: 0,
            octahedron: 0,
            icosahedron: 0,
            dodecahedron: 0,
            text: 0
        };

        // Undo/Redo History
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // Tab switching function
        function switchTab(tabName) {
            // Hide all tabs
            document.getElementById('shapes-content').classList.remove('block');
            document.getElementById('shapes-content').classList.add('hidden');
            document.getElementById('outliner-content').classList.remove('block');
            document.getElementById('outliner-content').classList.add('hidden');

            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('bg-gray-200', 'text-gray-700');
            });

            // Show selected tab
            if (tabName === 'shapes') {
                document.getElementById('shapes-content').classList.remove('hidden');
                document.getElementById('shapes-content').classList.add('block');
                buttons[0].classList.remove('bg-gray-200', 'text-gray-700');
                buttons[0].classList.add('bg-blue-500', 'text-white');
            } else if (tabName === 'outliner') {
                document.getElementById('outliner-content').classList.remove('hidden');
                document.getElementById('outliner-content').classList.add('block');
                buttons[1].classList.remove('bg-gray-200', 'text-gray-700');
                buttons[1].classList.add('bg-blue-500', 'text-white');
            }
        }

        function captureState() {
            // Remove any forward history if we made a new change
            history = history.slice(0, historyIndex + 1);

            // Create a snapshot of current state
            const state = {
                objects: objects.map(obj => {
                    const objState = {
                        name: obj.name,
                        position: obj.position.clone(),
                        rotation: obj.rotation.clone(),
                        scale: obj.scale.clone(),
                        color: obj.userData.color || obj.material.color.getHex(),
                        uuid: obj.uuid,
                        groupId: obj.userData.groupId || null
                    };
                    
                    // Store text-specific properties if present
                    if (obj.userData.textContent !== undefined) {
                        objState.textContent = obj.userData.textContent;
                        objState.textFont = obj.userData.textFont;
                        objState.textHeight = obj.userData.textHeight;
                        objState.textBevel = obj.userData.textBevel;
                    }
                    
                    return objState;
                }),
                groups: groups.map(g => ({
                    id: g.id,
                    name: g.name,
                    children: g.children.map(c => c.uuid)
                })),
                selectedObjectUuids: selectedObjects.map(obj => obj.uuid),
                shapeCounters: {
                    ...shapeCounters
                }
            };

            history.push(state);
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }

            updateHistoryButtons();
        }

        function restoreState(state) {
            if (!state) return;

            // Clear all outlines before restoring state
            for (let [mesh, outlineData] of outlineMap.entries()) {
                if (outlineData && outlineData.outline) {
                    scene.remove(outlineData.outline);
                    outlineData.outline.geometry.dispose();
                    outlineData.outline.material.dispose();
                }
            }
            outlineMap.clear();

            // Remove objects not in state
            objects.forEach(obj => scene.remove(obj));
            groups.forEach(g => {
                if (g.resultMesh) scene.remove(g.resultMesh);
            });
            objects = [];
            groups = [];

            // Recreate objects from state
            state.objects.forEach(objState => {
                // Find geometry type from name
                const type = objState.name.split(' ')[0].toLowerCase();
                let geometry;
                
                if (type === 'text') {
                    // Recreate text geometry
                    geometry = createTextGeometry(
                        objState.textContent || 'Text',
                        objState.textFont || 'sans',
                        objState.textHeight || 0.2,
                        objState.textBevel || 0.01
                    );
                    if (!geometry) {
                        console.warn('Text geometry not ready, skipping text object');
                        return;
                    }
                } else {
                    switch (type) {
                        case 'box':
                            geometry = new THREE.BoxGeometry(1, 1, 1);
                            break;
                        case 'sphere':
                            geometry = new THREE.SphereGeometry(0.5, 32, 32);
                            break;
                        case 'cylinder':
                            geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                            break;
                        case 'cone':
                            geometry = new THREE.ConeGeometry(0.5, 1, 32);
                            break;
                        case 'torus':
                            geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
                            break;
                        case 'plane':
                            geometry = new THREE.PlaneGeometry(1, 1);
                            break;
                        case 'pyramid':
                            geometry = new THREE.ConeGeometry(0.7, 1, 4);
                            break;
                        case 'torusknot':
                            geometry = new THREE.TorusKnotGeometry(0.4, 0.15, 100, 16);
                            break;
                        case 'tetrahedron':
                            geometry = new THREE.TetrahedronGeometry(0.7);
                            break;
                        case 'octahedron':
                            geometry = new THREE.OctahedronGeometry(0.7);
                            break;
                        case 'icosahedron':
                            geometry = new THREE.IcosahedronGeometry(0.7);
                            break;
                        case 'dodecahedron':
                            geometry = new THREE.DodecahedronGeometry(0.7);
                            break;
                    }

                    // Ensure geometry has proper bounds
                    geometry.computeBoundingBox();
                    geometry.computeBoundingSphere();
                    geometry.center();
                }

                // Create material
                const material = new THREE.MeshStandardMaterial({
                    color: objState.color,
                    roughness: 0.5,
                    metalness: 0.3,
                    transparent: false,
                    opacity: 1.0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = objState.name;
                mesh.uuid = objState.uuid;
                mesh.userData.color = objState.color;
                mesh.userData.groupId = objState.groupId || null;
                
                // Restore text properties if present
                if (objState.textContent !== undefined) {
                    mesh.userData.textContent = objState.textContent;
                    mesh.userData.textFont = objState.textFont;
                    mesh.userData.textHeight = objState.textHeight;
                    mesh.userData.textBevel = objState.textBevel;
                }
                
                mesh.position.copy(objState.position);
                mesh.rotation.copy(objState.rotation);
                mesh.scale.copy(objState.scale);
                mesh.castShadow = true;
                mesh.receiveShadow = true;

                scene.add(mesh);
                objects.push(mesh);
            });

            // Restore groups
            state.groups.forEach(groupState => {
                const group = {
                    id: groupState.id,
                    name: groupState.name,
                    children: groupState.children.map(uuid => objects.find(o => o.uuid === uuid)).filter(o =>
                        o),
                    resultMesh: null,
                    isDirty: true
                };
                groups.push(group);
                if (group.children.length > 0) {
                    computeGroupResult(group);
                }
            });

            shapeCounters = {
                ...state.shapeCounters
            };

            // Restore selection
            if (state.selectedObjectUuids && state.selectedObjectUuids.length > 0) {
                selectedObjects = [];
                state.selectedObjectUuids.forEach(uuid => {
                    const obj = objects.find(o => o.uuid === uuid);
                    if (obj) {
                        selectedObjects.push(obj);
                    }
                });
                selectedObject = selectedObjects.length > 0 ? selectedObjects[0] : null;

                if (selectedObjects.length === 1) {
                    document.getElementById('property-pane').classList.remove('hidden');
                    document.getElementById('property-pane').classList.add('block');
                    updatePropertyPane();
                    transformControls.attach(selectedObject);
                    createOutline(selectedObject);
                } else if (selectedObjects.length > 1) {
                    document.getElementById('property-pane').classList.add('hidden');
                    document.getElementById('property-pane').classList.remove('block');
                    transformControls.detach();
                }
            } else {
                deselectObject();
            }

            updateOutliner();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(history[historyIndex]);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(history[historyIndex]);
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');

            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        function createOutline(mesh) {
            if (!mesh.geometry) return null;
            
            // Create a silhouette outline using backface rendering
            // Clone the mesh and scale it slightly larger
            const outlineGeometry = mesh.geometry.clone();
            
            // Create outline material - black, rendered on back
            const outlineMaterial = new THREE.MeshBasicMaterial({
                color: OUTLINE_COLOR,
                side: THREE.BackSide,
                depthWrite: false,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
            });
            
            // Create outline mesh slightly scaled up
            const outlineObject = new THREE.Mesh(outlineGeometry, outlineMaterial);
            outlineObject.scale.multiplyScalar(1.05); // 5% larger to create silhouette
            
            // Use world position/rotation/scale to handle grouped objects correctly
            const worldPosition = new THREE.Vector3();
            const worldQuaternion = new THREE.Quaternion();
            const worldScale = new THREE.Vector3();
            
            mesh.getWorldPosition(worldPosition);
            mesh.getWorldQuaternion(worldQuaternion);
            mesh.getWorldScale(worldScale);
            
            outlineObject.position.copy(worldPosition);
            outlineObject.quaternion.copy(worldQuaternion);
            outlineObject.scale.copy(worldScale).multiplyScalar(1.05);
            
            // Add to scene
            scene.add(outlineObject);
            
            // Store reference with mesh reference for syncing
            outlineMap.set(mesh, { outline: outlineObject, mesh: mesh });
            
            return outlineObject;
        }

        function removeOutline(mesh) {
            const outlineData = outlineMap.get(mesh);
            if (outlineData) {
                scene.remove(outlineData.outline);
                outlineData.outline.geometry.dispose();
                outlineData.outline.material.dispose();
                outlineMap.delete(mesh);
            }
        }

        function syncOutlines() {
            // Sync all outline positions, rotations, and scales with their meshes
            for (let [mesh, outlineData] of outlineMap.entries()) {
                if (outlineData && outlineData.outline) {
                    // Use world position, rotation, and scale to handle grouped objects
                    const worldPosition = new THREE.Vector3();
                    const worldQuaternion = new THREE.Quaternion();
                    const worldScale = new THREE.Vector3();
                    
                    mesh.getWorldPosition(worldPosition);
                    mesh.getWorldQuaternion(worldQuaternion);
                    mesh.getWorldScale(worldScale);
                    
                    outlineData.outline.position.copy(worldPosition);
                    outlineData.outline.quaternion.copy(worldQuaternion);
                    // Scale: 1.05x of the original mesh scale
                    outlineData.outline.scale.copy(worldScale).multiplyScalar(1.05);
                }
            }
        }

        // Group Container - keeps shapes together with relative positions
        function computeGroupResult(group) {
            if (group.resultMesh) {
                scene.remove(group.resultMesh);
            }

            if (group.children.length === 0) return;

            // Calculate bounding box of all children to find center
            const boundingBox = new THREE.Box3();
            group.children.forEach(child => {
                boundingBox.expandByObject(child);
            });
            
            // Get the center of the bounding box
            const center = boundingBox.getCenter(new THREE.Vector3());

            // Create a THREE.Group container as the visual representation
            const groupContainer = new THREE.Group();
            groupContainer.userData.isGroupResult = true;
            groupContainer.userData.groupId = group.id;
            groupContainer.name = group.name;
            
            // Position the group container at the center of all children
            groupContainer.position.copy(center);

            // Add all children to the container, adjusting their positions to maintain world positions
            group.children.forEach(child => {
                // Store world position before parenting
                const worldPos = new THREE.Vector3();
                child.getWorldPosition(worldPos);
                
                // Parent to group
                groupContainer.add(child);
                
                // Restore world position by adjusting local position relative to group center
                child.position.copy(worldPos).sub(center);
            });

            scene.add(groupContainer);
            group.resultMesh = groupContainer;
            group.isDirty = false;
            console.log(`Group container created: ${group.name} with ${group.children.length} children at center:`, center);
        }

        function groupSelected() {
            if (selectedObjects.length < 1) {
                console.log("No objects selected for grouping");
                return;
            }

            console.log(`Grouping ${selectedObjects.length} objects`);

            const groupId = `group_${groupIdCounter++}`;
            const group = {
                id: groupId,
                name: `Group ${groups.length + 1}`,
                children: [...selectedObjects],
                resultMesh: null,
                isDirty: true
            };

            // Mark objects as part of group (they stay in scene, just parented)
            // Also remove any outlines from the objects being grouped
            selectedObjects.forEach(obj => {
                obj.userData.groupId = groupId;
                removeOutline(obj);
            });

            groups.push(group);
            computeGroupResult(group);

            deselectObject();
            selectObject(group.resultMesh);

            updateOutliner();
            captureState();
        }

        function ungroupSelected() {
            if (!selectedObject || !selectedObject.userData.isGroupResult) return;

            const groupId = selectedObject.userData.groupId;
            const groupIndex = groups.findIndex(g => g.id === groupId);

            if (groupIndex === -1) return;

            const group = groups[groupIndex];

            // Unparent objects and restore them to scene
            group.children.forEach(obj => {
                // Preserve world position when unparenting
                const worldPosition = new THREE.Vector3();
                const worldRotation = new THREE.Quaternion();
                const worldScale = new THREE.Vector3();
                obj.getWorldPosition(worldPosition);
                obj.getWorldQuaternion(worldRotation);
                obj.getWorldScale(worldScale);

                group.resultMesh.remove(obj);
                scene.add(obj);

                obj.position.copy(worldPosition);
                obj.quaternion.copy(worldRotation);
                obj.scale.copy(worldScale);

                obj.userData.groupId = null;
                deselectObject();
            });

            // Remove group container
            scene.remove(group.resultMesh);
            groups.splice(groupIndex, 1);

            updateOutliner();
            captureState();
        }

        function loadFonts() {
            // Load default fonts for text shapes
            const fontUrls = {
                sans: 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json',
                mono: 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/courier_new_regular.typeface.json',
                serif: 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/optimer_regular.typeface.json'
            };

            for (const [fontName, url] of Object.entries(fontUrls)) {
                fontLoader.load(url, (font) => {
                    fonts[fontName] = font;
                    console.log(`Font loaded: ${fontName}`);
                });
            }
        }

        function createTextGeometry(text, fontName = 'sans', height = 0.2, bevel = 0.01) {
            if (!fonts[fontName]) {
                console.warn(`Font ${fontName} not loaded yet, using sans-serif`);
                fontName = 'sans';
                if (!fonts[fontName]) {
                    return null; // Font not ready
                }
            }

            const geometry = new THREE.TextGeometry(text, {
                font: fonts[fontName],
                size: 1,
                height: height,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: bevel,
                bevelSize: bevel,
                bevelSegments: 5
            });

            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            geometry.center();

            return geometry;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(VIEWPORT_BG_COLOR);

            const aspect = window.innerWidth / window.innerHeight;
            perspectiveCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            const frustumSize = 10;
            orthographicCamera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2, 0.1, 1000);

            camera = perspectiveCamera;
            camera.position.set(5, 5, 5);

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const container = document.getElementById('canvas-container');
            container.appendChild(renderer.domElement);
            canvasElement = renderer.domElement;

            // Ensure canvas is clickable
            canvasElement.style.pointerEvents = 'auto';
            console.log("Canvas initialized:", canvasElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            gridHelper = new THREE.GridHelper(20, 20, GRID_COLOR_CENTER, GRID_COLOR_LINES);
            scene.add(gridHelper);

            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.setSpace('local'); // Align gizmo with object's local axes
            transformControls.addEventListener('dragging-changed', event => {
                controls.enabled = !event.value;
                if (!event.value) {
                    // Capture state when transform finishes
                    captureState();
                }
            });
            transformControls.addEventListener('objectChange', updatePropertyPane);
            scene.add(transformControls);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Single click listener on canvas
            canvasElement.addEventListener('click', onCanvasClick, false);
            console.log("Canvas click listener attached");

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);

            updateSnapSettings();
            setTransformMode('translate');
            updateOutliner();
            updateHistoryButtons();
            
            // Load fonts for text shapes
            loadFonts();
            
            animate();
        }

        function onCanvasClick(event) {
            console.log("‚úì Canvas click fired, target:", event.target.tagName);
            performRaycast(event);
        }

        function performRaycast(event) {
            if (transformControls.dragging) return;

            const rect = canvasElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Collect all selectable objects
            const selectableObjects = [];
            objects.forEach(obj => {
                if (obj.visible && !obj.userData.isGroupResult) {
                    selectableObjects.push(obj);
                }
            });
            groups.forEach(group => {
                if (group.resultMesh && group.resultMesh.visible) {
                    selectableObjects.push(group.resultMesh);
                }
            });

            const intersects = raycaster.intersectObjects(selectableObjects);

            console.log("üñ±Ô∏è Click - Objects:", selectableObjects.length, "Hits:", intersects.length);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                console.log("‚úÖ Hit:", clickedObject.name);

                // Ctrl/Cmd + click for multi-select
                if (event.ctrlKey || event.metaKey) {
                    console.log("Ctrl+Click - Multi-select mode");
                    toggleObjectSelection(clickedObject);
                } else {
                    console.log("Regular click - Single select");
                    selectObject(clickedObject);
                }
            } else {
                console.log("‚ùå Missed");
                deselectObject();
            }
        }

        function addShape(type) {
            let geometry;
            
            if (type === 'text') {
                // Special handling for text shapes
                geometry = createTextGeometry('Text', 'sans', 0.2, 0.01);
                if (!geometry) {
                    alert('Text fonts are still loading. Please try again in a moment.');
                    return;
                }
            } else {
                switch (type) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(0.5, 32, 32);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(0.5, 1, 32);
                        break;
                    case 'torus':
                        geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
                        break;
                    case 'plane':
                        geometry = new THREE.PlaneGeometry(1, 1);
                        break;
                    case 'pyramid':
                        geometry = new THREE.ConeGeometry(0.7, 1, 4);
                        break;
                    case 'torusknot':
                        geometry = new THREE.TorusKnotGeometry(0.4, 0.15, 100, 16);
                        break;
                    case 'tetrahedron':
                        geometry = new THREE.TetrahedronGeometry(0.7);
                        break;
                    case 'octahedron':
                        geometry = new THREE.OctahedronGeometry(0.7);
                        break;
                    case 'icosahedron':
                        geometry = new THREE.IcosahedronGeometry(0.7);
                        break;
                    case 'dodecahedron':
                        geometry = new THREE.DodecahedronGeometry(0.7);
                        break;
                }

                // Ensure geometry has proper bounds
                geometry.computeBoundingBox();
                geometry.computeBoundingSphere();
                geometry.center();
            }

            const material = new THREE.MeshStandardMaterial({
                color: '#007370',
                roughness: 0.5,
                metalness: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            shapeCounters[type]++;
            mesh.name = `${type.charAt(0).toUpperCase() + type.slice(1)} ${shapeCounters[type]}`;
            
            // Set default y-position based on shape type
            if (type === 'plane') {
                mesh.position.y = 0;
            } else if (type === 'text') {
                mesh.position.y = 0.1;
            } else {
                mesh.position.y = 0.5;
            }
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.color = '#007370';
            
            // Set default rotation for plane and text to lay flat
            if (type === 'plane' || type === 'text') {
                mesh.rotation.x = THREE.MathUtils.degToRad(-90);
            }
            
            // Store text-specific properties
            if (type === 'text') {
                mesh.userData.textContent = 'Text';
                mesh.userData.textFont = 'sans';
                mesh.userData.textHeight = 0.2;
                mesh.userData.textBevel = 0.01;
            }
            
            scene.add(mesh);
            objects.push(mesh);
            selectObject(mesh);
            captureState();
        }

        function deselectObject() {
            if (selectedObject) {
                removeOutline(selectedObject);
                // Also remove outlines from group children if deselecting a group
                const selGroup = groups.find(g => g.resultMesh === selectedObject);
                if (selGroup) {
                    selGroup.children.forEach(child => {
                        removeOutline(child);
                    });
                }
            }
            if (selectedObjects.length > 0) {
                selectedObjects.forEach(sel => {
                    removeOutline(sel);
                    // Remove outlines from group children if deselecting a group
                    const selGroup = groups.find(g => g.resultMesh === sel);
                    if (selGroup) {
                        selGroup.children.forEach(child => {
                            removeOutline(child);
                        });
                    }
                });
            }
            selectedObject = null;
            selectedObjects = [];
            transformControls.detach();
            document.getElementById('property-pane').classList.add('hidden');
            document.getElementById('property-pane').classList.remove('block');
            updateOutliner();
        }

        function toggleObjectSelection(obj) {
            // Check if already selected
            const index = selectedObjects.indexOf(obj);
            if (index > -1) {
                // Remove from selection
                selectedObjects.splice(index, 1);
                if (!obj.userData.isGroupResult) {
                    removeOutline(obj);
                }
                console.log(`Deselected: ${obj.name}, Total selected: ${selectedObjects.length}`);
            } else {
                // Add to selection
                selectedObjects.push(obj);
                if (!obj.userData.isGroupResult) {
                    createOutline(obj);
                }
                console.log(`Selected: ${obj.name}, Total selected: ${selectedObjects.length}`);
            }

            // Update references
            selectedObject = selectedObjects.length > 0 ? selectedObjects[0] : null;

            // Show property pane only if 1 object selected
            if (selectedObjects.length === 1) {
                document.getElementById('property-pane').classList.remove('hidden');
                document.getElementById('property-pane').classList.add('block');
                updatePropertyPane();
                transformControls.attach(selectedObject);
            } else if (selectedObjects.length > 1) {
                // Multiple selection - hide property pane
                document.getElementById('property-pane').classList.add('hidden');
                document.getElementById('property-pane').classList.remove('block');
                transformControls.detach();
            } else {
                // No selection
                document.getElementById('property-pane').classList.add('hidden');
                document.getElementById('property-pane').classList.remove('block');
                transformControls.detach();
            }

            updateOutliner();
        }

        function selectObject(obj) {
            if (!obj) return;

            // If object is part of a group, select the group container instead
            if (obj.userData.groupId) {
                const groupId = obj.userData.groupId;
                const group = groups.find(g => g.id === groupId);
                if (group && group.resultMesh) {
                    obj = group.resultMesh;
                    console.log(`Object is part of group, selecting group container instead`);
                }
            }

            // Clear previous selection and start fresh
            selectedObjects.forEach(sel => {
                removeOutline(sel);
                // Also remove outlines from group children
                const selGroup = groups.find(g => g.resultMesh === sel);
                if (selGroup) {
                    selGroup.children.forEach(child => {
                        removeOutline(child);
                    });
                }
            });

            selectedObjects = [obj];
            selectedObject = obj;

            // If selecting a group, add outlines to the group container and all its children
            if (selectedObject.userData.isGroupResult) {
                const group = groups.find(g => g.resultMesh === selectedObject);
                if (group) {
                    // Add outlines to all children in the group
                    group.children.forEach(child => {
                        createOutline(child);
                    });
                    console.log(`Group selected: outlining ${group.children.length} children`);
                }
            } else {
                // Add outline to individual shape
                createOutline(selectedObject);
            }

            transformControls.attach(selectedObject);
            document.getElementById('property-pane').classList.remove('hidden');
            document.getElementById('property-pane').classList.add('block');
            updatePropertyPane();
            updateOutliner();
            console.log(`Single selected: ${obj.name}`);
        }

        function updateOutliner() {
            const outlinerList = document.getElementById('outliner-list');
            outlinerList.innerHTML = '';

            // Track which objects are already in groups
            const objectsInGroups = new Set();
            groups.forEach(group => {
                group.children.forEach(child => {
                    objectsInGroups.add(child.uuid);
                });
            });

            // Show groups with their children
            groups.forEach(group => {
                // Create group container item
                const groupLi = document.createElement('li');
                groupLi.className =
                    'text-sm rounded-md cursor-pointer transition-all bg-slate-50 text-gray-900 border border-transparent';
                if (selectedObjects.includes(group.resultMesh)) {
                    groupLi.classList.add('bg-slate-200', 'font-semibold');
                }

                const groupHeader = document.createElement('div');
                groupHeader.className = 'flex items-center gap-2 p-3 hover:bg-slate-100 rounded-md';
                groupHeader.innerHTML =
                    `<i class="fa-regular fa-object-group"></i><span>${group.name}</span> <span class="text-xs text-gray-600 ml-auto">(${group.children.length})</span>`;
                groupHeader.onclick = () => {
                    selectObject(group.resultMesh);
                };
                groupLi.appendChild(groupHeader);

                // Create collapsible children container
                const childrenUl = document.createElement('ul');
                childrenUl.className = 'ml-4 border-l-2 border-slate-300 pl-2 space-y-1';

                group.children.forEach(child => {
                    if (child.visible) {
                        const childLi = document.createElement('li');
                        childLi.className =
                            'text-sm p-2 rounded-md cursor-pointer transition-all bg-transparent text-gray-800 flex items-center gap-2 border border-transparent';
                        if (selectedObjects.includes(child)) {
                            childLi.classList.add('bg-blue-100', 'font-semibold');
                        }
                        childLi.classList.add('hover:bg-sky-100');

                        childLi.innerHTML = `<i class="fa-solid fa-cube"></i><span>${child.name}</span>`;
                        childLi.onclick = (e) => {
                            if (e.ctrlKey || e.metaKey) {
                                toggleObjectSelection(child);
                            } else {
                                selectObject(child);
                            }
                        };
                        childrenUl.appendChild(childLi);
                    }
                });

                groupLi.appendChild(childrenUl);
                outlinerList.appendChild(groupLi);
            });

            // Show ungrouped objects
            objects.forEach(obj => {
                if (obj.visible && !objectsInGroups.has(obj.uuid)) {
                    const li = document.createElement('li');
                    li.className =
                        'text-sm p-3 rounded-md cursor-pointer transition-all bg-transparent text-gray-900 flex items-center gap-2 border border-transparent';
                    if (selectedObjects.includes(obj)) {
                        li.classList.add('bg-blue-200', 'font-semibold');
                    }
                    li.classList.add('hover:bg-sky-100');

                    li.innerHTML = `<i class="fa-solid fa-cube"></i><span>${obj.name}</span>`;
                    li.onclick = (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            toggleObjectSelection(obj);
                        } else {
                            selectObject(obj);
                        }
                    };
                    outlinerList.appendChild(li);
                }
            });
        }

        function onKeyDown(e) {
            if (e.target.tagName === 'INPUT') return;
            switch (e.key.toLowerCase()) {
                case 't':
                    setTransformMode('translate');
                    break;
                case 'r':
                    setTransformMode('rotate');
                    break;
                case 's':
                    setTransformMode('scale');
                    break;
                case 'delete':
                case 'backspace':
                    deleteSelected();
                    e.preventDefault();
                    break;
                case 'z':
                    if (e.ctrlKey) {
                        undo();
                        e.preventDefault();
                    }
                    break;
                case 'y':
                    if (e.ctrlKey) {
                        redo();
                        e.preventDefault();
                    }
                    break;
            }
        }

        function updateSnapSettings() {
            const selectElement = document.getElementById('snap-unit-select');
            const newSnapValue = parseFloat(selectElement.value);
            if (newSnapValue === 0) {
                transformControls.setTranslationSnap(null);
                transformControls.setRotationSnap(null);
                transformControls.setScaleSnap(null);
            } else {
                transformControls.setTranslationSnap(newSnapValue);
                transformControls.setRotationSnap(THREE.MathUtils.degToRad(15));
                transformControls.setScaleSnap(newSnapValue);
            }
        }

        function setTransformMode(mode) {
            transformControls.setMode(mode);
            const buttons = {
                translate: document.getElementById('translate-btn'),
                rotate: document.getElementById('rotate-btn'),
                scale: document.getElementById('scale-btn')
            };
            for (const key in buttons) {
                const button = buttons[key];
                if (key === mode) {
                    button.style.backgroundColor = '#1e40af';
                } else {
                    button.style.backgroundColor = '#3b82f6';
                }
            }
        }

        function setCameraMode(mode) {
            if (mode === currentCameraMode) return;
            const newCam = (mode === 'perspective') ? perspectiveCamera : orthographicCamera;
            newCam.position.copy(camera.position);
            newCam.rotation.copy(camera.rotation);
            newCam.zoom = camera.zoom;
            camera = newCam;
            controls.object = camera;
            transformControls.camera = camera;
            camera.updateProjectionMatrix();
            controls.update();
            currentCameraMode = mode;
            const pBtn = document.getElementById('perspective-btn');
            const oBtn = document.getElementById('orthographic-btn');

            if (mode === 'perspective') {
                pBtn.style.backgroundColor = '#1e40af';
                oBtn.style.backgroundColor = '#3b82f6';
            } else {
                pBtn.style.backgroundColor = '#3b82f6';
                oBtn.style.backgroundColor = '#1e40af';
            }
        }

        function updateColor() {
            if (selectedObject) {
                const newColor = document.getElementById('colorPicker').value;
                selectedObject.userData.color = newColor;
                selectedObject.material.color.set(newColor);
                // Update hex input to match
                document.getElementById('hexInput').value = newColor.replace('#', '');
                captureState();
            }
        }

        function updateColorFromHex() {
            if (selectedObject) {
                let hexValue = document.getElementById('hexInput').value;
                // Add # if not present
                if (!hexValue.startsWith('#')) {
                    hexValue = '#' + hexValue;
                }
                // Validate hex color format
                if (/^#[0-9A-Fa-f]{6}$/.test(hexValue)) {
                    selectedObject.userData.color = hexValue;
                    selectedObject.material.color.set(hexValue);
                    // Update color picker to match
                    document.getElementById('colorPicker').value = hexValue;
                    captureState();
                } else {
                    // Invalid hex, revert to current color
                    const currentColor = document.getElementById('colorPicker').value;
                    document.getElementById('hexInput').value = currentColor.replace('#', '');
                }
            }
        }

        function duplicateSelected() {
            if (selectedObjects.length === 0) return;

            console.log(`Duplicating ${selectedObjects.length} objects`);
            const clones = [];

            selectedObjects.forEach(obj => {
                const clone = obj.clone();
                clone.material = obj.material.clone();
                clone.position.x += 1.5;
                let originalType = obj.name.split(' ')[0].toLowerCase();
                shapeCounters[originalType]++;
                clone.name =
                    `${originalType.charAt(0).toUpperCase() + originalType.slice(1)} ${shapeCounters[originalType]}`;
                scene.add(clone);
                objects.push(clone);
                clones.push(clone);
            });

            // Select all the clones
            deselectObject();
            clones.forEach(clone => {
                selectedObjects.push(clone);
                createOutline(clone);
            });
            selectedObject = clones.length > 0 ? clones[0] : null;

            if (clones.length === 1) {
                document.getElementById('property-pane').classList.remove('hidden');
                document.getElementById('property-pane').classList.add('block');
                updatePropertyPane();
                transformControls.attach(selectedObject);
            } else if (clones.length > 1) {
                document.getElementById('property-pane').classList.add('hidden');
                document.getElementById('property-pane').classList.remove('block');
            }

            updateOutliner();
            captureState();
        }

        function deleteSelected() {
            if (selectedObjects.length === 0) return;

            console.log(`Deleting ${selectedObjects.length} objects`);
            selectedObjects.forEach(objToRemove => {
                // Check if this is a group container being deleted
                const groupIndex = groups.findIndex(g => g.resultMesh === objToRemove);
                if (groupIndex !== -1) {
                    // Delete the entire group
                    const group = groups[groupIndex];
                    // Remove group container from scene
                    scene.remove(group.resultMesh);
                    // Remove all children from objects array
                    group.children.forEach(child => {
                        objects = objects.filter(obj => obj !== child);
                    });
                    // Remove group from groups array
                    groups.splice(groupIndex, 1);
                    console.log(`Deleted group: ${group.name}`);
                } else {
                    // Regular object deletion
                    scene.remove(objToRemove);
                    objects = objects.filter(obj => obj !== objToRemove);
                }
            });

            deselectObject();
            updateOutliner();
            captureState();
        }

        function closePropertyPane() {
            deselectObject();
        }

        function updatePropertyPane() {
            if (!selectedObject) return;

            // Check if selected object is a group
            const isGroup = selectedObject.userData.isGroupResult === true;
            const materialSection = document.getElementById('property-material-section');
            const textSection = document.getElementById('property-text-section');
            const isText = selectedObject.userData.textContent !== undefined;
            
            if (isGroup) {
                // Hide material section for groups
                materialSection.classList.add('hidden');
                textSection.classList.add('hidden');
            } else {
                // Show material section for regular shapes (except text)
                if (isText) {
                    materialSection.classList.add('hidden');
                    textSection.classList.remove('hidden');
                    
                    // Populate text properties
                    document.getElementById('prop-text-content').value = selectedObject.userData.textContent || 'Text';
                    document.getElementById('prop-text-font').value = selectedObject.userData.textFont || 'sans';
                    document.getElementById('prop-text-height').value = selectedObject.userData.textHeight || 0.2;
                    document.getElementById('prop-text-bevel').value = selectedObject.userData.textBevel || 0.01;
                } else {
                    materialSection.classList.remove('hidden');
                    textSection.classList.add('hidden');
                    
                    // Handle color - check userData or material
                    let colorValue = '#007370';
                    if (selectedObject.userData && selectedObject.userData.color) {
                        colorValue = selectedObject.userData.color;
                    } else if (selectedObject.material && selectedObject.material.color) {
                        colorValue = '#' + selectedObject.material.color.getHexString();
                    }

                    // Ensure color value starts with #
                    if (typeof colorValue === 'string' && !colorValue.startsWith('#')) {
                        colorValue = '#' + colorValue;
                    }
                    document.getElementById('colorPicker').value = colorValue;
                    // Update hex input to match
                    document.getElementById('hexInput').value = colorValue.replace('#', '');
                }
            }

            document.getElementById('prop-pos-x').value = selectedObject.position.x.toFixed(3);
            document.getElementById('prop-pos-y').value = selectedObject.position.y.toFixed(3);
            document.getElementById('prop-pos-z').value = selectedObject.position.z.toFixed(3);
            document.getElementById('prop-rot-x').value = THREE.MathUtils.radToDeg(selectedObject.rotation.x).toFixed(1);
            document.getElementById('prop-rot-y').value = THREE.MathUtils.radToDeg(selectedObject.rotation.y).toFixed(1);
            document.getElementById('prop-rot-z').value = THREE.MathUtils.radToDeg(selectedObject.rotation.z).toFixed(1);
            document.getElementById('prop-scale-x').value = selectedObject.scale.x.toFixed(3);
            document.getElementById('prop-scale-y').value = selectedObject.scale.y.toFixed(3);
            document.getElementById('prop-scale-z').value = selectedObject.scale.z.toFixed(3);
        }

        function updateTextContent() {
            if (!selectedObject || !selectedObject.userData.textContent) return;
            
            const newContent = document.getElementById('prop-text-content').value || 'Text';
            selectedObject.userData.textContent = newContent;
            updateTextGeometry();
            captureState();
        }

        function updateTextFont() {
            if (!selectedObject || !selectedObject.userData.textContent) return;
            
            const newFont = document.getElementById('prop-text-font').value || 'sans';
            selectedObject.userData.textFont = newFont;
            updateTextGeometry();
            captureState();
        }

        function updateTextHeight() {
            if (!selectedObject || !selectedObject.userData.textContent) return;
            
            const newHeight = parseFloat(document.getElementById('prop-text-height').value) || 0.2;
            selectedObject.userData.textHeight = newHeight;
            updateTextGeometry();
            captureState();
        }

        function updateTextBevel() {
            if (!selectedObject || !selectedObject.userData.textContent) return;
            
            const newBevel = parseFloat(document.getElementById('prop-text-bevel').value) || 0.01;
            selectedObject.userData.textBevel = newBevel;
            updateTextGeometry();
            captureState();
        }

        function updateTextGeometry() {
            if (!selectedObject || !selectedObject.userData.textContent) return;
            
            const newGeometry = createTextGeometry(
                selectedObject.userData.textContent,
                selectedObject.userData.textFont,
                selectedObject.userData.textHeight,
                selectedObject.userData.textBevel
            );

            if (newGeometry) {
                // Dispose old geometry
                selectedObject.geometry.dispose();
                
                // Update geometry
                selectedObject.geometry = newGeometry;
                
                // Sync outline if it exists
                const outlineData = outlineMap.get(selectedObject);
                if (outlineData && outlineData.outline) {
                    removeOutline(selectedObject);
                    createOutline(selectedObject);
                }
            }
        }

        function updateObjectFromPane() {
            if (!selectedObject) return;
            selectedObject.position.set(parseFloat(document.getElementById('prop-pos-x').value), parseFloat(document
                .getElementById('prop-pos-y').value), parseFloat(document.getElementById('prop-pos-z').value));
            selectedObject.rotation.set(THREE.MathUtils.degToRad(parseFloat(document.getElementById('prop-rot-x').value)),
                THREE.MathUtils.degToRad(parseFloat(document.getElementById('prop-rot-y').value)), THREE.MathUtils
                .degToRad(parseFloat(document.getElementById('prop-rot-z').value)));
            selectedObject.scale.set(parseFloat(document.getElementById('prop-scale-x').value), parseFloat(document
                .getElementById('prop-scale-y').value), parseFloat(document.getElementById('prop-scale-z').value));
            captureState();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function exportGLTF() {
            if (objects.length === 0) {
                alert('No objects to export');
                return;
            }

            // Create a temporary group to hold all objects
            const exportGroup = new THREE.Group();
            objects.forEach(obj => {
                // Clone the object to avoid modifying the original scene
                const clonedObj = obj.clone();
                if (clonedObj.material) {
                    clonedObj.material = clonedObj.material.clone();
                }
                exportGroup.add(clonedObj);
            });

            const exporter = new THREE.GLTFExporter();
            exporter.parse(exportGroup, function (result) {
                const output = JSON.stringify(result, null, 2);
                const blob = new Blob([output], { type: 'application/json' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `scene_${new Date().getTime()}.gltf`;
                link.click();
                URL.revokeObjectURL(link.href);
                console.log('GLTF exported successfully');
            });
        }

        function exportSTL() {
            if (objects.length === 0) {
                alert('No objects to export');
                return;
            }

            // Create a temporary group to hold all objects
            const exportGroup = new THREE.Group();
            objects.forEach(obj => {
                // Clone the object to avoid modifying the original scene
                const clonedObj = obj.clone();
                if (clonedObj.material) {
                    clonedObj.material = clonedObj.material.clone();
                }
                exportGroup.add(clonedObj);
            });

            const exporter = new THREE.STLExporter();
            const stlString = exporter.parse(exportGroup);
            const blob = new Blob([stlString], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `scene_${new Date().getTime()}.stl`;
            link.click();
            URL.revokeObjectURL(link.href);
            console.log('STL exported successfully');
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            syncOutlines();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>
